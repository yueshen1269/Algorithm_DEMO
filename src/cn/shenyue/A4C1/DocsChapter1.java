package cn.shenyue.A4C1;

public class DocsChapter1 {
    /**
     * 1.2
     *  1. 数据类型： 指的是一组值和一组对这些值操作的集合
     *  2. Java编程的基础主要是使用class关键字构造被称为引用类型的数据类型
     *  3. 抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型，他将数据和函数的实现关联，并将函数的表示
     *      方式隐藏起来
     *  4. 对象是能够承载数据类型的值的实体，三大特性：状态、标识（内存地址）、行为
     *  5. 面向对象编程： 运用数据抽象的思想编写代码（定义和使用数据类型，将数据类型的值封装在对象中）的方式
     *  6. 要定义数据类型的值（即每个对象的状态），我们需要声明实例变量
     *  7. 每个Java类都至少含有一个构造函数来创建一个对象的标识，构造函数将创建一个对象并返回一个该对象的引用
     *  8. 实现数据类型的实例方法（即每个对象的行为），实例方法可以访问并操作实例变量
     *  9. Java代码中的三种变量： 参数变量，局部变量，实例变量
     *  10. 抽象数据类型的实现都是一个含有若干私有实例变量、构造函数、实例方法和一个测试用例的Java类
     *  11. 按照三步走的方式用抽象数据类型满足他们
     *      1.定义一份API：API的作用是将实现和使用分离，以实现模块化编程，目的有二：
     *          1.我们希望用例的代码清晰且正确
     *          2.我们希望能够实现这些操作
     *      2.用一个Java类实现API的定义： 选择适当的实例变量，再编写构造函数和实例方法
     *      3.实现多个测试用例来证明前两步做出的设计决定
     *  12. 用例一般需要声明操作，数据类型的值应该是什么才能最好地支持这些操作，这些基本的判断是我们开发的
     *      每种实现的核心内容
     *  13. 我们需要理解各种实现对空间和时间的需求以及它们对各种用例的适用性
     *  14. 在实现中使用数据抽象的一个关键优势是我们可以将一种实现替换为另一种而无需改变用例的任何代码
     *  15. 数据抽象天生适合算法研究
     *  16. 数据抽象使我们能够
     *      1.准确定义算法能为用例提供什么
     *      2.隔离算法的实现和用例的代码
     *      3.实现多层抽象，用已知算法实现其他算法
     * 1.3 背包、队列和栈
     *  1.背包是一种不支持从中删除元素的集合数据类型--它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素
     *  2.队列是一种基于先进先出策略的集合类型
     *  3.栈是一种基于后进先出策略的集合类型
     *  4.算术表达式求值（双栈算法，一个保存操作数，一个保存操作符）
     *      * 将操作数压入操作数栈
     *      * 将操作符压入操作符栈
     *      * 忽略左括号
     *      * 遇到右括号，弹出一个运算符，弹出所需数量的操作数，并将运算结果压入操作数栈
     *  5.定容栈（容量固定）
     *  7.对象游离
     *      Java的垃圾收集策略是回收所有无法被访问的对象的内存
     *      从栈中弹出一个元素，用例不在需要这个元素，但数组中的引用仍然可以让他继续存在，
     *      这种情况下（保存一个不需要的引用对象）称为对象游离
     *  8.迭代
     *      Stack<String> collection = new Stack<String>();
     *      for(String s : t) StdOut.println(s);
     *
     *      for-each 语句是while语句的一种简写方式
     *
     *      Iterator<String> i = collection.iterator();
     *      while(i.hasNext()) {
     *          String s= i.next();
     *          StdOut.println(s);
     *      }
     *      任意可迭代的集合数据类型中我们都需要实现的东西：
     *      1.集合数据类型必须实现一个iterator()方法并返回一个Iterator对象
     *      2.Iterator类必须包含两个方法：hasNext() 和 next()
     *  9.链表
     *      1.链表是一种递归的数据结构，它或者为空（null)，或者是指向一个结点（node)的引用，该结点
     *      含有一个泛型的元素和一个指向另一条链表的引用
     *      2.结点的数据类型
     *          private class node {
     *              Item item;
     *              Node next;
     *          }
     *      3.构造链表：根据递归定义，我们只需要一个Node类型的变量就能表示一条链表，只要保证它的值是null或者
     *          指向另一个Node对象且该对象的next域指向了另一条链表即可
     */
}
